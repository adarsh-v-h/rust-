The fn main(), creates a function called main, in rust just like C/C++ is where the execution begins.
The file has the exetention .rs and is first converted to .exe file, by the command, "rustc file_name", then ran with .\main.exe.
Here println! is a rust macro, not a function, the "!" mark at the end tells if its a macro or just a normal function, they are not the same.
"Hello, world!" as a string is passed as an argument to println.
";" is important as it tells the termination of a line.
First we usually compile the code to an exe file with "rustc file_name", the file thats executed is .exe.
The .pdb exetension file contains the information for debugging.
Cargo is a package manager, which handles the dependencies.
The command to create a dir with cargo and have created files in it already is "cargo new dir_name".
The files created by it are cargo.toml and a main.rs file and it has also initialized a new git repo along with .gitignore file.
Note: we can stop this or change this, to something else like some different version control system, using the --vcs flag. 
Next if we head to .toml file, we will see package and dependencies, tomol = Tom's obvious, Minimal Language.
First part is package, which is followed by statements that are configuring a package. In it we will have the name, the version and the edition of RUST to use.
Next is the dependencies section, about it later. In RUST, the packages of code are referred to as crates.
When we run Cargo new, the main file is in a sub dir called "src", and other files are in top dir.
The "cargo build" command creates an exe file in a sub-sub dir, target\debug\file.exe, because defaulf build is debug build. 
The cargo.lock keeps track of the exact version and dependencies in your project.
The "cargo run" complies and executed the file. If there is no change in the file after the build, then it directly executes, if there is, then it complies and then executes.
The "cargo check" command complies the code without creating an exe file. Its better for regular checking, and is faster than "cargo build" as it doesnt create an exe file.
THE steps are as follows: 1. create a new project with cargo new, 2. we build a project with cargo build, 3. we can build and run with cargo run, 4. we can check code without exe file with cargo check.
The command "cargo build --release" this will create an exe file in target/release, this makes the code faster.
Crate is a collection of Rust source code. Before using any library create, we need to add it in the toml file in dependencies section.
Crates.io is where people in the Rust ecosystem post their open source Rust projects for others to use.
When we add a Crate to dependencies section and run "cargo build", it downloads those dependencies crates and also the crate that dependes on.
cargo.lock file helps to keep track of the versions of libraries, so the code doesnt break in future becasue of an update.
We can update any any crate by running, cargo update, it will check the latest version of the crates used in the project and update to the suitable one.
There are particular changes need to be made in toml file, we decide to use something 0.1.0 higher than mentioned,
if we assume we used the rand library of version = 0.8.5, we cant update to 0.9.0 or anything 0.9.x, if we want to, we need to make changes in the toml file. 
The command "cargo doc --open", will open online present documentaions on the dependencies we have used in the project locally.
 
